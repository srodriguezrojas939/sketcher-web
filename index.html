<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProCAD Sketcher v2 - Estabilidad y Precisi√≥n</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Open+Sans:wght@400;600&display=swap');
        :root { --bg: #F3F4F6; --panel: #FFFFFF; --black: #111827; --blue: #2563EB; --red: #EF4444; --gray: #9CA3AF; --fixed: #059669; }
        body { margin: 0; font-family: 'Open Sans', sans-serif; background: var(--bg); color: var(--black); display: grid; grid-template-columns: 260px 1fr 280px; grid-template-rows: auto 1fr; height: 100vh; overflow: hidden; }
        header { grid-column: 1 / -1; padding: 10px 25px; background: var(--panel); border-bottom: 1px solid #E5E7EB; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        header h1 { font-family: 'Playfair Display', serif; font-size: 18px; margin: 0; }
        .sidebar, .right-panel { background: var(--panel); padding: 15px; overflow-y: auto; border-color: #E5E7EB; border-style: solid; }
        .sidebar { border-right-width: 1px; display: flex; flex-direction: column; gap: 8px; }
        .right-panel { border-left-width: 1px; }
        .tool-group h3 { font-size: 10px; text-transform: uppercase; color: var(--gray); margin: 0 0 8px 0; letter-spacing: 1px; }
        .btn { width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #F3F4F6; background: white; cursor: pointer; font-weight: 600; text-align: left; display: flex; align-items: center; gap: 10px; font-size: 13px; transition: 0.2s; }
        .btn:hover { background: #F9FAFB; }
        .btn.active { background: var(--black); color: white; }
        .undo-redo-row { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 10px; }
        #viewport { position: relative; background: white; overflow: hidden; cursor: crosshair; }
        svg { width: 100%; height: 100%; touch-action: none; }
        .sketch-line { stroke: var(--black); stroke-width: 2; fill: none; }
        .sketch-circle { stroke: var(--black); stroke-width: 2; fill: rgba(0,0,0,0.02); }
        .point { fill: white; stroke: var(--black); stroke-width: 1.5; cursor: move; }
        .point.fixed { fill: var(--fixed); stroke: var(--fixed); }
        .dim-text { fill: var(--blue); font-weight: 700; font-size: 11px; cursor: pointer; user-select: none; }
        .angle-text { fill: var(--red); font-weight: 700; font-size: 11px; cursor: pointer; }
        .constraint-item { font-size: 11px; padding: 6px; background: #F9FAFB; border: 1px solid #E5E7EB; border-radius: 4px; margin-bottom: 3px; }
    </style>
</head>
<body>

<header>
    <h1>ProCAD Sketcher v2</h1>
    <div style="font-family: 'Playfair Display'; font-weight: 700; font-size: 14px;">‚àö(Raiz) Cuadrada¬≤</div>
</header>

<div class="sidebar">
    <div class="undo-redo-row">
        <button class="btn" onclick="sketcher.undo()">‚ü≤ Undo</button>
        <button class="btn" onclick="sketcher.redo()">‚ü≥ Redo</button>
    </div>
    <div class="tool-group">
        <h3>Primitivas</h3>
        <button class="btn active" id="btn-LINE" onclick="sketcher.setMode('LINE')">üìè L√≠nea</button>
        <button class="btn" id="btn-CIRCLE" onclick="sketcher.setMode('CIRCLE')">‚≠ï C√≠rculo</button>
        <button class="btn" id="btn-RECT" onclick="sketcher.setMode('RECT')">üü¶ Rect√°ngulo</button>
    </div>
    <div class="tool-group">
        <h3>Restricciones</h3>
        <button class="btn" onclick="sketcher.setMode('DIM')">üè∑Ô∏è Acotar Longitud</button>
        <button class="btn" onclick="sketcher.setMode('ANGLE')">üìê Acotar √Ångulo</button>
        <button class="btn" onclick="sketcher.applyStatic('HORIZ')">‚ñ¨ Horizontal</button>
        <button class="btn" onclick="sketcher.applyStatic('VERT')">‚ñÆ Vertical</button>
        <button class="btn" onclick="sketcher.toggleFixed()">‚öì Fijar Punto (Ground)</button>
    </div>
    <div class="tool-group">
        <h3>Modificaci√≥n</h3>
        <button class="btn" id="btn-TRIM" onclick="sketcher.setMode('TRIM')">‚úÇÔ∏è Tijeras (Trim)</button>
    </div>
</div>

<div id="viewport">
    <svg id="canvas"></svg>
</div>

<div class="right-panel">
    <div class="tool-group">
        <h3>Grafos de Restricci√≥n</h3>
        <div id="constraint-list"></div>
    </div>
</div>

<script>
class SketchState {
    constructor() {
        this.points = [];
        this.segments = [];
        this.circles = [];
        this.constraints = [];
    }
    clone() {
        const newState = new SketchState();
        newState.points = JSON.parse(JSON.stringify(this.points));
        newState.segments = JSON.parse(JSON.stringify(this.segments));
        newState.circles = JSON.parse(JSON.stringify(this.circles));
        newState.constraints = JSON.parse(JSON.stringify(this.constraints));
        return newState;
    }
}

class CADSketcher {
    constructor() {
        this.state = new SketchState();
        this.history = [];
        this.redoStack = [];
        this.mode = 'LINE';
        this.tempIds = [];
        this.dragNode = null;
        this.EPS = 1e-6;
        this.svg = document.getElementById('canvas');
        this.initEvents();
    }

    saveHistory() {
        this.history.push(this.state.clone());
        this.redoStack = [];
        if (this.history.length > 50) this.history.shift();
    }

    undo() {
        if (this.history.length > 0) {
            this.redoStack.push(this.state.clone());
            this.state = this.history.pop();
            this.render();
        }
    }

    redo() {
        if (this.redoStack.length > 0) {
            this.history.push(this.state.clone());
            this.state = this.redoStack.pop();
            this.render();
        }
    }

    // --- SOLVER DE RESTRICCIONES (POS) ---
    solve() {
        const iterations = 40;
        for (let i = 0; i < iterations; i++) {
            let maxErr = 0;
            this.state.constraints.forEach(c => {
                const err = this.applyConstraint(c);
                maxErr = Math.max(maxErr, err);
            });
            if (maxErr < this.EPS) break;
        }
    }

    applyConstraint(c) {
        if (c.type === 'DIST') {
            const s = this.state.segments.find(seg => seg.id === c.targetId);
            if (!s) return 0;
            const p1 = this.findPoint(s.p1Id), p2 = this.findPoint(s.p2Id);
            const dx = p2.x - p1.x, dy = p2.y - p1.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < this.EPS) return 0;
            const ratio = (dist - c.value) / dist * 0.5;
            this.movePoint(p1, dx * ratio, dy * ratio);
            this.movePoint(p2, -dx * ratio, -dy * ratio);
            return Math.abs(dist - c.value);
        }
        if (c.type === 'HORIZ' || c.type === 'VERT') {
            const s = this.state.segments.find(seg => seg.id === c.targetId);
            if (!s) return 0;
            const p1 = this.findPoint(s.p1Id), p2 = this.findPoint(s.p2Id);
            if (c.type === 'HORIZ') {
                const avgY = (p1.y + p2.y) / 2;
                this.setPointPos(p1, null, avgY);
                this.setPointPos(p2, null, avgY);
                return Math.abs(p1.y - p2.y);
            } else {
                const avgX = (p1.x + p2.x) / 2;
                this.setPointPos(p1, avgX, null);
                this.setPointPos(p2, avgX, null);
                return Math.abs(p1.x - p2.x);
            }
        }
        if (c.type === 'ANGLE') {
            const s1 = this.state.segments.find(s => s.id === c.s1Id);
            const s2 = this.state.segments.find(s => s.id === c.s2Id);
            if (!s1 || !s2) return 0;

            // Encontrar v√©rtice com√∫n
            const commonId = [s1.p1Id, s1.p2Id].find(id => id === s2.p1Id || id === s2.p2Id);
            if (!commonId) return 0;

            const v = this.findPoint(commonId);
            const other1Id = (s1.p1Id === commonId) ? s1.p2Id : s1.p1Id;
            const other2Id = (s2.p1Id === commonId) ? s2.p2Id : s2.p1Id;
            const p1 = this.findPoint(other1Id), p2 = this.findPoint(other2Id);

            const a1 = Math.atan2(p1.y - v.y, p1.x - v.x);
            const a2 = Math.atan2(p2.y - v.y, p2.x - v.x);
            const targetRad = c.value * (Math.PI / 180);
            const diff = targetRad - (a2 - a1);

            // Rotar p2 alrededor de v
            const cos = Math.cos(diff), sin = Math.sin(diff);
            const rx = p2.x - v.x, ry = p2.y - v.y;
            this.setPointPos(p2, v.x + (rx * cos - ry * sin), v.y + (rx * sin + ry * cos));
            return Math.abs(diff);
        }
        return 0;
    }

    movePoint(p, dx, dy) {
        if (p.fixed || p === this.dragNode) return;
        p.x += dx; p.y += dy;
    }

    setPointPos(p, x, y) {
        if (p.fixed || p === this.dragNode) return;
        if (x !== null) p.x = x;
        if (y !== null) p.y = y;
    }

    // --- GEOMETR√çA Y DETECCI√ìN ---
    findPoint(id) { return this.state.points.find(p => p.id === id); }

    getSegmentDist(x, y, seg) {
        const p1 = this.findPoint(seg.p1Id), p2 = this.findPoint(seg.p2Id);
        const l2 = Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2);
        if (l2 === 0) return Math.hypot(x - p1.x, y - p1.y);
        let t = ((x - p1.x) * (p2.x - p1.x) + (y - p1.y) * (p2.y - p1.y)) / l2;
        t = Math.max(0, Math.min(1, t)); // Clamp al segmento
        return Math.hypot(x - (p1.x + t * (p2.x - p1.x)), y - (p1.y + t * (p2.y - p1.y)));
    }

    trim(x, y) {
        this.saveHistory();
        const seg = this.state.segments.find(s => this.getSegmentDist(x, y, s) < 10);
        if (seg) {
            this.state.constraints = this.state.constraints.filter(c => c.targetId !== seg.id && c.s1Id !== seg.id && c.s2Id !== seg.id);
            this.state.segments = this.state.segments.filter(s => s.id !== seg.id);
        }
        const circ = this.state.circles.find(c => {
            const p = this.findPoint(c.centerId);
            return Math.abs(Math.hypot(x - p.x, y - p.y) - c.radius) < 10;
        });
        if (circ) this.state.circles = this.state.circles.filter(c => c.id !== circ.id);
        
        // Limpiar puntos hu√©rfanos
        this.state.points = this.state.points.filter(p => 
            this.state.segments.some(s => s.p1Id === p.id || s.p2Id === p.id) ||
            this.state.circles.some(c => c.centerId === p.id)
        );
        this.render();
    }

    // --- UI Y EVENTOS ---
    initEvents() {
        this.svg.onmousedown = (e) => {
            const { x, y } = this.getCoords(e);
            const snap = this.state.points.find(p => Math.hypot(p.x - x, p.y - y) < 12);

            if (this.mode === 'TRIM') return this.trim(x, y);

            const p = snap || { x, y, id: 'P' + Date.now(), fixed: false };
            if (!snap) this.state.points.push(p);

            if (this.mode === 'LINE') {
                if (this.tempIds[0]) {
                    this.saveHistory();
                    const seg = { p1Id: this.tempIds[0], p2Id: p.id, id: 'S' + Date.now() };
                    this.state.segments.push(seg);
                    this.state.constraints.push({ type: 'DIST', targetId: seg.id, value: Math.hypot(this.findPoint(seg.p1Id).x - p.x, this.findPoint(seg.p1Id).y - p.y) });
                    this.tempIds = [];
                } else { this.tempIds = [p.id]; }
            } else if (this.mode === 'RECT') {
                this.saveHistory();
                const p1 = p, p2 = {x: p.x+80, y:p.y, id:'P'+Date.now()+'2'}, p3 = {x:p.x+80, y:p.y+50, id:'P'+Date.now()+'3'}, p4 = {x:p.x, y:p.y+50, id:'P'+Date.now()+'4'};
                p1.fixed = true; // Auto ground
                this.state.points.push(p2,p3,p4);
                const s1 = {p1Id:p1.id, p2Id:p2.id, id:'SR1'}, s2 = {p1Id:p2.id, p2Id:p3.id, id:'SR2'}, s3 = {p1Id:p3.id, p2Id:p4.id, id:'SR3'}, s4 = {p1Id:p4.id, p2Id:p1.id, id:'SR4'};
                this.state.segments.push(s1,s2,s3,s4);
                this.state.constraints.push({type:'HORIZ', targetId:s1.id}, {type:'VERT', targetId:s2.id}, {type:'DIST', targetId:s1.id, value:80}, {type:'DIST', targetId:s2.id, value:50});
            } else if (this.mode === 'ANGLE') {
                const seg = this.state.segments.find(s => this.getSegmentDist(x, y, s) < 10);
                if (seg) {
                    if (this.tempIds[0] && this.tempIds[0] !== seg.id) {
                        this.saveHistory();
                        this.state.constraints.push({ type: 'ANGLE', s1Id: this.tempIds[0], s2Id: seg.id, value: 90 });
                        this.tempIds = [];
                    } else { this.tempIds = [seg.id]; }
                }
            } else if (this.mode === 'DIM') {
                const seg = this.state.segments.find(s => this.getSegmentDist(x, y, s) < 10);
                if (seg) this.editDimension(seg.id, 'DIST');
            } else {
                if (snap) this.dragNode = snap;
            }
            this.solve();
            this.render();
        };

        window.onmousemove = (e) => {
            if (this.dragNode) {
                const { x, y } = this.getCoords(e);
                this.dragNode.x = x; this.dragNode.y = y;
                this.solve();
                this.render();
            }
        };
        window.onmouseup = () => this.dragNode = null;
    }

    getCoords(e) { const r = this.svg.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; }

    setMode(m) { this.mode = m; this.tempIds = []; document.querySelectorAll('.btn').forEach(b => b.classList.toggle('active', b.id === 'btn-'+m)); }

    toggleFixed() {
        if (this.dragNode) { this.saveHistory(); this.dragNode.fixed = !this.dragNode.fixed; this.render(); }
        else alert("Haz clic y arrastra un punto mientras presionas este bot√≥n (o simplemente selecciona 'Mover' primero)");
    }

    applyStatic(type) {
        const last = this.state.segments[this.state.segments.length - 1];
        if (last) { this.saveHistory(); this.state.constraints.push({ type, targetId: last.id }); this.solve(); this.render(); }
    }

    editDimension(id, type) {
        const c = this.state.constraints.find(c => (c.targetId === id || c.s2Id === id) && c.type === type);
        if (!c) return;
        const val = prompt(`Valor para ${type}:`, Math.round(c.value));
        if (val !== null && !isNaN(val)) { this.saveHistory(); c.value = parseFloat(val); this.solve(); this.render(); }
    }

    render() {
        const canvas = this.svg; canvas.innerHTML = '';
        this.state.segments.forEach(s => {
            const p1 = this.findPoint(s.p1Id), p2 = this.findPoint(s.p2Id);
            const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
            l.setAttribute("x1", p1.x); l.setAttribute("y1", p1.y);
            l.setAttribute("x2", p2.x); l.setAttribute("y2", p2.y);
            l.setAttribute("class", "sketch-line");
            canvas.appendChild(l);
            
            // Texto de dimensi√≥n
            const distC = this.state.constraints.find(c => c.targetId === s.id && c.type === 'DIST');
            if (distC) {
                const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
                t.setAttribute("x", (p1.x + p2.x)/2); t.setAttribute("y", (p1.y + p2.y)/2 - 10);
                t.setAttribute("class", "dim-text"); t.setAttribute("text-anchor", "middle");
                t.textContent = Math.round(distC.value);
                t.onclick = () => this.editDimension(s.id, 'DIST');
                canvas.appendChild(t);
            }
        });

        this.state.constraints.filter(c => c.type === 'ANGLE').forEach(c => {
            const s1 = this.state.segments.find(s => s.id === c.s1Id);
            const p = this.findPoint(s1.p1Id);
            const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
            t.setAttribute("x", p.x + 20); t.setAttribute("y", p.y - 20);
            t.setAttribute("class", "angle-text");
            t.textContent = Math.round(c.value) + "¬∞";
            t.onclick = () => this.editDimension(c.s2Id, 'ANGLE');
            canvas.appendChild(t);
        });

        this.state.points.forEach(p => {
            const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            c.setAttribute("cx", p.x); c.setAttribute("cy", p.y);
            c.setAttribute("r", 4);
            c.setAttribute("class", `point ${p.fixed ? 'fixed' : ''}`);
            canvas.appendChild(c);
        });

        document.getElementById('constraint-list').innerHTML = this.state.constraints.map(c => `<div class="constraint-item"><b>${c.type}</b>: ${Math.round(c.value || 0)}</div>`).join('');
    }
}

const sketcher = new CADSketcher();
</script>
</body>
</html>
