<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProCAD Sketcher v3.1 - Professional Stability</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Open+Sans:wght@400;600&display=swap');
        :root { 
            --bg: #F3F4F6; --panel: #FFFFFF; --black: #111827; 
            --blue: #2563EB; --red: #EF4444; --gray: #9CA3AF; 
            --fixed: #064E3B; --defined: #10B981; --sub: #3B82F6;
            --select: #F59E0B; --hover: #D1D5DB;
        }
        body { margin: 0; font-family: 'Open Sans', sans-serif; background: var(--bg); color: var(--black); display: grid; grid-template-columns: 280px 1fr 280px; grid-template-rows: auto 1fr; height: 100vh; overflow: hidden; }
        header { grid-column: 1 / -1; padding: 10px 25px; background: var(--panel); border-bottom: 1px solid #E5E7EB; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        header h1 { font-family: 'Playfair Display', serif; font-size: 18px; margin: 0; }
        .sidebar, .right-panel { background: var(--panel); padding: 15px; overflow-y: auto; border-color: #E5E7EB; border-style: solid; }
        .sidebar { border-right-width: 1px; display: flex; flex-direction: column; gap: 8px; }
        .right-panel { border-left-width: 1px; }
        .tool-group h3 { font-size: 10px; text-transform: uppercase; color: var(--gray); margin: 0 0 8px 0; letter-spacing: 1px; }
        .btn { width: 100%; padding: 8px 10px; border-radius: 6px; border: 1px solid #F3F4F6; background: white; cursor: pointer; font-weight: 600; text-align: left; display: flex; align-items: center; gap: 10px; font-size: 12px; transition: 0.2s; }
        .btn:hover { background: #F9FAFB; }
        .btn.active { background: var(--black); color: white; }
        .undo-redo-row { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 10px; }
        #viewport { position: relative; background: white; overflow: hidden; cursor: crosshair; }
        svg { width: 100%; height: 100%; touch-action: none; }
        
        .sketch-line { stroke: var(--black); stroke-width: 2; fill: none; }
        .sketch-line.selected { stroke: var(--select); stroke-width: 3; }
        .sketch-line.hover { stroke: var(--hover); }
        .sketch-circle { stroke: var(--black); stroke-width: 2; fill: rgba(0,0,0,0.02); }
        .sketch-circle.selected { stroke: var(--select); stroke-width: 3; }
        .point { stroke-width: 1.5; cursor: move; }
        .point.selected { stroke: var(--select); stroke-width: 3; }
        .dim-text { fill: var(--blue); font-weight: 700; font-size: 11px; cursor: pointer; user-select: none; }
        .angle-text { fill: var(--red); font-weight: 700; font-size: 11px; cursor: pointer; }
        .constraint-item { font-size: 11px; padding: 6px; background: #F9FAFB; border: 1px solid #E5E7EB; border-radius: 4px; margin-bottom: 3px; display: flex; justify-content: space-between; align-items: center; }
        .btn-del-c { color: var(--red); border: none; background: none; cursor: pointer; font-weight: bold; font-size: 14px; }
    </style>
</head>
<body>

<header>
    <h1>ProCAD Sketcher v3.1</h1>
    <div style="font-family: 'Playfair Display'; font-weight: 700; font-size: 14px;">SOLVER &#931;</div>
</header>

<div class="sidebar">
    <div class="undo-redo-row">
        <button class="btn" onclick="sketcher.undo()">&#8634; Deshacer</button>
        <button class="btn" onclick="sketcher.redo()">&#8635; Rehacer</button>
    </div>
    
    <div class="tool-group">
        <h3>Dibujo</h3>
        <button class="btn active" id="btn-LINE" onclick="sketcher.setMode('LINE')">&#9473; Linea</button>
        <button class="btn" id="btn-CIRCLE" onclick="sketcher.setMode('CIRCLE')">&#9675; Circulo</button>
        <button class="btn" id="btn-RECT" onclick="sketcher.setMode('RECT')">&#9645; Rectangulo</button>
        <button class="btn" id="btn-SELECT" onclick="sketcher.setMode('SELECT')">&#10146; Seleccion</button>
    </div>

    <div class="tool-group">
        <h3>Restricciones</h3>
        <button class="btn" onclick="sketcher.setMode('DIM')">&#8614; Distancia</button>
        <button class="btn" onclick="sketcher.setMode('ANGLE')">&#8736; Angulo</button>
        <button class="btn" onclick="sketcher.addConstraintFromSelection('HORIZ')">&#9113; Horizontal</button>
        <button class="btn" onclick="sketcher.addConstraintFromSelection('VERT')">&#9114; Vertical</button>
        <button class="btn" onclick="sketcher.addConstraintFromSelection('COINCIDENT')">&#128279; Coincidir</button>
        <button class="btn" onclick="sketcher.addConstraintFromSelection('MIDPOINT')">&#8982; Pto Medio</button>
        <button class="btn" onclick="sketcher.addConstraintFromSelection('EQUAL')">&#128700; Igualar</button>
        <button class="btn" onclick="sketcher.addConstraintFromSelection('PARALLEL')">&#8741; Paralelo</button>
        <button class="btn" onclick="sketcher.addConstraintFromSelection('PERPENDICULAR')">&#8869; Perp.</button>
        <button class="btn" onclick="sketcher.toggleFixed()">&#9875; Ground</button>
    </div>

    <div class="tool-group">
        <h3>Edicion</h3>
        <button class="btn" id="btn-TRIM" onclick="sketcher.setMode('TRIM')">&#9988; Trim</button>
    </div>
</div>

<div id="viewport">
    <svg id="canvas"></svg>
</div>

<div class="right-panel">
    <div class="tool-group">
        <h3>Listado</h3>
        <div id="constraint-list"></div>
    </div>
</div>

<script>
class SketchState {
    constructor() {
        this.points = [];
        this.segments = [];
        this.circles = [];
        this.constraints = [];
    }
    clone() {
        const newState = new SketchState();
        newState.points = JSON.parse(JSON.stringify(this.points));
        newState.segments = JSON.parse(JSON.stringify(this.segments));
        newState.circles = JSON.parse(JSON.stringify(this.circles));
        newState.constraints = JSON.parse(JSON.stringify(this.constraints));
        return newState;
    }
}

class CADSketcher {
    constructor() {
        this.state = new SketchState();
        this.history = [];
        this.redoStack = [];
        this.mode = 'LINE';
        this.tempIds = [];
        this.dragNode = null;
        this.EPS = 1e-6;
        this.selectedIds = new Set();
        this.hoverId = null;
        this.svg = document.getElementById('canvas');
        this.initEvents();
    }

    saveHistory() {
        this.history.push(this.state.clone());
        this.redoStack = [];
        if (this.history.length > 50) this.history.shift();
    }

    // BUG FIX: Asegurar restauracion completa de estados incluyendo tempIds
    undo() {
        if (this.history.length > 0) {
            this.redoStack.push(this.state.clone());
            this.state = this.history.pop();
            this.tempIds = []; // BUG FIX
            this.selectedIds.clear(); // BUG FIX
            this.render();
        }
    }

    redo() {
        if (this.redoStack.length > 0) {
            this.history.push(this.state.clone());
            this.state = this.redoStack.pop();
            this.tempIds = []; // BUG FIX
            this.render();
        }
    }

    solve() {
        const iterations = 50;
        for (let i = 0; i < iterations; i++) {
            let maxErr = 0;
            this.state.constraints.forEach(c => {
                maxErr = Math.max(maxErr, this.applyConstraint(c));
            });
            if (maxErr < this.EPS) break;
        }
    }

    applyConstraint(c) {
        if (c.type === 'DIST') {
            const s = this.state.segments.find(seg => seg.id === c.targetId);
            if (!s) return 0;
            const p1 = this.findPoint(s.p1Id), p2 = this.findPoint(s.p2Id);
            const dx = p2.x - p1.x, dy = p2.y - p1.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < this.EPS) return 0;
            const ratio = (dist - c.value) / dist * 0.5;
            this.movePoint(p1, dx * ratio, dy * ratio);
            this.movePoint(p2, -dx * ratio, -dy * ratio);
            return Math.abs(dist - c.value);
        }
        if (c.type === 'HORIZ' || c.type === 'VERT') {
            const s = this.state.segments.find(seg => seg.id === c.targetId);
            if (!s) return 0;
            const p1 = this.findPoint(s.p1Id), p2 = this.findPoint(s.p2Id);
            if (c.type === 'HORIZ') {
                const avgY = (p1.y + p2.y) / 2;
                this.setPointPos(p1, null, avgY); this.setPointPos(p2, null, avgY);
                return Math.abs(p1.y - p2.y);
            } else {
                const avgX = (p1.x + p2.x) / 2;
                this.setPointPos(p1, avgX, null); this.setPointPos(p2, avgX, null);
                return Math.abs(p1.x - p2.x);
            }
        }
        if (c.type === 'ANGLE') {
            const s1 = this.state.segments.find(s => s.id === c.s1Id);
            const s2 = this.state.segments.find(s => s.id === c.s2Id);
            if (!s1 || !s2) return 0;
            const vId = [s1.p1Id, s1.p2Id].find(id => id === s2.p1Id || id === s2.p2Id);
            if (!vId) return 0; // BUG FIX: Validacion de vertice compartido
            const v = this.findPoint(vId);
            const p1 = this.findPoint(s1.p1Id === vId ? s1.p2Id : s1.p1Id);
            const p2 = this.findPoint(s2.p1Id === vId ? s2.p2Id : s2.p1Id);
            
            // BUG FIX: Evitar division por cero y NaN
            const d1 = Math.hypot(p1.x - v.x, p1.y - v.y);
            const d2 = Math.hypot(p2.x - v.x, p2.y - v.y);
            if (d1 < this.EPS || d2 < this.EPS) return 0;

            const a1 = Math.atan2(p1.y - v.y, p1.x - v.x);
            const a2 = Math.atan2(p2.y - v.y, p2.x - v.x);
            const currentAngle = (a2 - a1) * 180 / Math.PI;
            const diff = (c.value - currentAngle) * Math.PI / 180;
            
            // BUG FIX: Amortiguacion (damping) para evitar loops infinitos en conflictos
            const step = diff * 0.5;
            const cos = Math.cos(step), sin = Math.sin(step);
            const rx = p2.x - v.x, ry = p2.y - v.y;
            this.setPointPos(p2, v.x + (rx * cos - ry * sin), v.y + (rx * sin + ry * cos));
            return Math.abs(diff);
        }
        // Restricciones adicionales (Coincidente, Midpoint, etc.)
        if (c.type === 'COINCIDENT') {
            const pA = this.findPoint(c.p1Id);
            if (c.p2Id) {
                const pB = this.findPoint(c.p2Id);
                const mx = (pA.x + pB.x) / 2, my = (pA.y + pB.y) / 2;
                this.setPointPos(pA, mx, my); this.setPointPos(pB, mx, my);
                return Math.hypot(pA.x - pB.x, pA.y - pB.y);
            } else if (c.segId) {
                const s = this.state.segments.find(seg => seg.id === c.segId);
                if (!s) return 0;
                const sp1 = this.findPoint(s.p1Id), sp2 = this.findPoint(s.p2Id);
                const dx = sp2.x - sp1.x, dy = sp2.y - sp1.y;
                const l2 = dx*dx + dy*dy;
                let t = l2 === 0 ? 0 : ((pA.x - sp1.x) * dx + (pA.y - sp1.y) * dy) / l2;
                t = Math.max(0, Math.min(1, t));
                const px = sp1.x + t * dx, py = sp1.y + t * dy;
                const err = Math.hypot(pA.x - px, pA.y - py);
                this.setPointPos(pA, px, py);
                return err;
            }
        }
        if (c.type === 'MIDPOINT') {
            const p = this.findPoint(c.pId), s = this.state.segments.find(seg => seg.id === c.segId);
            if (!s) return 0;
            const sp1 = this.findPoint(s.p1Id), sp2 = this.findPoint(s.p2Id);
            const mx = (sp1.x + sp2.x) / 2, my = (sp1.y + sp2.y) / 2;
            const err = Math.hypot(p.x - mx, p.y - my);
            this.setPointPos(p, mx, my);
            return err;
        }
        if (c.type === 'EQUAL') {
            const s1 = this.state.segments.find(s => s.id === c.s1Id);
            const s2 = this.state.segments.find(s => s.id === c.s2Id);
            if (!s1 || !s2) return 0;
            const l1 = Math.hypot(this.findPoint(s1.p1Id).x - this.findPoint(s1.p2Id).x, this.findPoint(s1.p1Id).y - this.findPoint(s1.p2Id).y);
            const l2 = Math.hypot(this.findPoint(s2.p1Id).x - this.findPoint(s2.p2Id).x, this.findPoint(s2.p1Id).y - this.findPoint(s2.p2Id).y);
            const avg = (l1 + l2) / 2;
            this.applyConstraint({type: 'DIST', targetId: s1.id, value: avg});
            this.applyConstraint({type: 'DIST', targetId: s2.id, value: avg});
            return Math.abs(l1 - l2);
        }
        if (c.type === 'PARALLEL' || c.type === 'PERPENDICULAR') {
            const s1 = this.state.segments.find(s => s.id === c.s1Id), s2 = this.state.segments.find(s => s.id === c.s2Id);
            if (!s1 || !s2) return 0;
            const p1a = this.findPoint(s1.p1Id), p1b = this.findPoint(s1.p2Id), p2a = this.findPoint(s2.p1Id), p2b = this.findPoint(s2.p2Id);
            const a1 = Math.atan2(p1b.y - p1a.y, p1b.x - p1a.x);
            const target = c.type === 'PARALLEL' ? a1 : a1 + Math.PI/2;
            const l2 = Math.hypot(p2b.x - p2a.x, p2b.y - p2a.y);
            const nx = p2a.x + Math.cos(target) * l2, ny = p2a.y + Math.sin(target) * l2;
            const err = Math.hypot(p2b.x - nx, p2b.y - ny);
            this.setPointPos(p2b, nx, ny);
            return err;
        }
        return 0;
    }

    movePoint(p, dx, dy) { if (!p.fixed && p !== this.dragNode) { p.x += dx; p.y += dy; } }
    setPointPos(p, x, y) { if (!p.fixed && p !== this.dragNode) { if (x !== null) p.x = x; if (y !== null) p.y = y; } }
    findPoint(id) { return this.state.points.find(p => p.id === id); }

    getSegmentDist(x, y, seg) {
        const p1 = this.findPoint(seg.p1Id), p2 = this.findPoint(seg.p2Id);
        const l2 = Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2);
        if (l2 === 0) return Math.hypot(x - p1.x, y - p1.y);
        let t = Math.max(0, Math.min(1, ((x - p1.x) * (p2.x - p1.x) + (y - p1.y) * (p2.y - p1.y)) / l2));
        return Math.hypot(x - (p1.x + t * (p2.x - p1.x)), y - (p1.y + t * (p2.y - p1.y)));
    }

    initEvents() {
        this.svg.onmousedown = (e) => {
            const { x, y } = this.getCoords(e);
            const snapP = this.state.points.find(p => Math.hypot(p.x - x, p.y - y) < 12);
            const snapS = this.state.segments.find(s => this.getSegmentDist(x, y, s) < 8);
            
            if (this.mode === 'SELECT') {
                const target = snapP || snapS;
                if (!e.shiftKey) this.selectedIds.clear();
                if (target) this.selectedIds.has(target.id) ? this.selectedIds.delete(target.id) : this.selectedIds.add(target.id);
            } else if (this.mode === 'TRIM') {
                this.trim(x, y);
            } else if (this.mode === 'LINE') {
                const p = snapP || { x, y, id: 'P' + Date.now() + Math.random(), fixed: false };
                if (!snapP) this.state.points.push(p);
                if (this.tempIds[0]) {
                    this.saveHistory();
                    const s = { p1Id: this.tempIds[0], p2Id: p.id, id: 'S' + Date.now() };
                    this.state.segments.push(s);
                    this.state.constraints.push({ type: 'DIST', targetId: s.id, value: Math.hypot(this.findPoint(s.p1Id).x - p.x, this.findPoint(s.p1Id).y - p.y) });
                    this.tempIds = [];
                } else this.tempIds = [p.id];
            } else if (this.mode === 'CIRCLE') {
                const p = snapP || { x, y, id: 'P' + Date.now(), fixed: false };
                if (!snapP) this.state.points.push(p);
                if (this.tempIds[0]) {
                    this.saveHistory();
                    this.state.circles.push({ centerId: this.tempIds[0], radiusPointId: p.id, id: 'C' + Date.now() });
                    this.tempIds = [];
                } else this.tempIds = [p.id];
            } else if (this.mode === 'RECT') {
                this.saveHistory();
                const p1 = snapP || {x, y, id: 'P'+Date.now()+'1', fixed: true};
                if(!snapP) this.state.points.push(p1);
                const p2={x:x+80,y,id:'P'+Date.now()+'2'}, p3={x:x+80,y:y+50,id:'P'+Date.now()+'3'}, p4={x,y:y+50,id:'P'+Date.now()+'4'};
                this.state.points.push(p2, p3, p4);
                const s1={p1Id:p1.id,p2Id:p2.id,id:'S'+Date.now()+'1'}, s2={p1Id:p2.id,p2Id:p3.id,id:'S'+Date.now()+'2'}, s3={p1Id:p3.id,p2Id:p4.id,id:'S'+Date.now()+'3'}, s4={p1Id:p4.id,p2Id:p1.id,id:'S'+Date.now()+'4'};
                this.state.segments.push(s1,s2,s3,s4);
                this.state.constraints.push({type:'HORIZ',targetId:s1.id},{type:'VERT',targetId:s2.id},{type:'DIST',targetId:s1.id,value:80},{type:'DIST',targetId:s2.id,value:50});
            } else if (this.mode === 'ANGLE') {
                if (snapS) {
                    if (this.tempIds[0] && this.tempIds[0] !== snapS.id) {
                        const s1 = this.state.segments.find(s => s.id === this.tempIds[0]);
                        const s2 = snapS;
                        const vId = [s1.p1Id, s1.p2Id].find(id => id === s2.p1Id || id === s2.p2Id);
                        
                        if (vId) { // BUG FIX: Solo permitir si comparten vertice
                            this.saveHistory();
                            const v = this.findPoint(vId), p1 = this.findPoint(s1.p1Id === vId ? s1.p2Id : s1.p1Id), p2 = this.findPoint(s2.p1Id === vId ? s2.p2Id : s2.p1Id);
                            // BUG FIX: Calcular angulo inicial real
                            const val = (Math.atan2(p2.y-v.y, p2.x-v.x) - Math.atan2(p1.y-v.y, p1.x-v.x)) * 180 / Math.PI;
                            this.state.constraints.push({ type: 'ANGLE', s1Id: s1.id, s2Id: s2.id, value: val });
                            this.tempIds = [];
                        } else { this.tempIds = []; }
                    } else this.tempIds = [snapS.id];
                }
            } else if (this.mode === 'DIM' && snapS) {
                this.editDimension(snapS.id, 'DIST');
            } else if (snapP) {
                this.dragNode = snapP;
            }
            this.solve(); this.render();
        };

        window.onmousemove = (e) => {
            const { x, y } = this.getCoords(e);
            const hP = this.state.points.find(p => Math.hypot(p.x - x, p.y - y) < 12);
            const hS = this.state.segments.find(s => this.getSegmentDist(x, y, s) < 8);
            this.hoverId = hP ? hP.id : (hS ? hS.id : null);
            if (this.dragNode) { this.dragNode.x = x; this.dragNode.y = y; this.solve(); }
            this.render();
        };
        window.onmouseup = () => this.dragNode = null;
    }

    getCoords(e) { const r = this.svg.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; }
    setMode(m) { this.mode = m; this.tempIds = []; document.querySelectorAll('.btn').forEach(b => b.classList.toggle('active', b.id === 'btn-'+m)); }

    addConstraintFromSelection(type) {
        const sel = Array.from(this.selectedIds);
        if (sel.length === 0) return;
        this.saveHistory();
        if (type === 'HORIZ' || type === 'VERT') {
            sel.forEach(id => { if (id.startsWith('S')) this.state.constraints.push({type, targetId: id}); });
        } else if (type === 'COINCIDENT') {
            const p = sel.filter(i => i.startsWith('P')), s = sel.filter(i => i.startsWith('S'));
            if (p.length === 2) this.state.constraints.push({type, p1Id: p[0], p2Id: p[1]});
            else if (p.length === 1 && s.length === 1) this.state.constraints.push({type, p1Id: p[0], segId: s[0]});
        } else if (type === 'MIDPOINT') {
            const p = sel.find(i => i.startsWith('P')), s = sel.find(i => i.startsWith('S'));
            if (p && s) this.state.constraints.push({type, pId: p, segId: s});
        } else if (['EQUAL','PARALLEL','PERPENDICULAR'].includes(type)) {
            const s = sel.filter(i => i.startsWith('S'));
            if (s.length === 2) this.state.constraints.push({type, s1Id: s[0], s2Id: s[1]});
        }
        this.selectedIds.clear(); this.solve(); this.render();
    }

    toggleFixed() {
        if (this.selectedIds.size > 0) {
            this.saveHistory();
            this.selectedIds.forEach(id => { const p = this.findPoint(id); if (p) p.fixed = !p.fixed; });
            this.render();
        }
    }

    deleteConstraint(i) { this.saveHistory(); this.state.constraints.splice(i, 1); this.solve(); this.render(); }

    editDimension(id, type) {
        const c = this.state.constraints.find(c => (c.targetId === id || c.s2Id === id) && c.type === type);
        if (!c) return;
        const val = prompt(`Valor ${type}:`, Math.round(c.value));
        if (val !== null && !isNaN(val)) { this.saveHistory(); c.value = parseFloat(val); this.solve(); this.render(); }
    }

    // BUG FIX: Eliminacion de TODAS las restricciones dependientes
    trim(x, y) {
        const seg = this.state.segments.find(s => this.getSegmentDist(x, y, s) < 10);
        if (seg) {
            this.saveHistory();
            const sid = seg.id;
            this.state.segments = this.state.segments.filter(s => s.id !== sid);
            // BUG FIX: Limpieza recursiva de referencias
            this.state.constraints = this.state.constraints.filter(c => 
                c.targetId !== sid && c.s1Id !== sid && c.s2Id !== sid && c.segId !== sid
            );
            // Limpieza de puntos huerfanos
            this.state.points = this.state.points.filter(p => 
                this.state.segments.some(s => s.p1Id === p.id || s.p2Id === p.id) ||
                this.state.circles.some(c => c.centerId === p.id || c.radiusPointId === p.id)
            );
            // BUG FIX: Limpiar restricciones de puntos que se borraron
            const liveP = new Set(this.state.points.map(p => p.id));
            this.state.constraints = this.state.constraints.filter(c => {
                const pKeys = ['p1Id', 'p2Id', 'pId'];
                return !pKeys.some(k => c[k] && !liveP.has(c[k]));
            });
        }
        this.render();
    }

    render() {
        const canvas = this.svg; canvas.innerHTML = '';
        this.state.segments.forEach(s => {
            const p1 = this.findPoint(s.p1Id), p2 = this.findPoint(s.p2Id);
            const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
            l.setAttribute("x1", p1.x); l.setAttribute("y1", p1.y); l.setAttribute("x2", p2.x); l.setAttribute("y2", p2.y);
            l.setAttribute("class", `sketch-line ${this.selectedIds.has(s.id)?'selected':''} ${this.hoverId===s.id?'hover':''}`);
            canvas.appendChild(l);
            const dC = this.state.constraints.find(c => c.targetId === s.id && c.type === 'DIST');
            if (dC) {
                const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
                t.setAttribute("x", (p1.x+p2.x)/2); t.setAttribute("y", (p1.y+p2.y)/2-10);
                t.setAttribute("class", "dim-text"); t.setAttribute("text-anchor", "middle");
                t.textContent = Math.round(dC.value);
                t.onclick = (e) => { e.stopPropagation(); this.editDimension(s.id, 'DIST'); };
                canvas.appendChild(t);
            }
        });
        this.state.constraints.filter(c => c.type === 'ANGLE').forEach(c => {
            const s1 = this.state.segments.find(s => s.id === c.s1Id), s2 = this.state.segments.find(s => s.id === c.s2Id);
            if (!s1 || !s2) return;
            const v = this.findPoint([s1.p1Id, s1.p2Id].find(id => id === s2.p1Id || id === s2.p2Id));
            if (!v) return;
            const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
            t.setAttribute("x", v.x+20); t.setAttribute("y", v.y-20);
            t.setAttribute("class", "angle-text");
            t.textContent = Math.round(c.value) + 'Â°';
            t.onclick = () => this.editDimension(c.s2Id, 'ANGLE');
            canvas.appendChild(t);
        });
        this.state.points.forEach(p => {
            const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            c.setAttribute("cx", p.x); c.setAttribute("cy", p.y); c.setAttribute("r", 4);
            const relC = this.state.constraints.filter(cn => [cn.targetId, cn.p1Id, cn.p2Id, cn.pId].includes(p.id) || this.state.segments.some(s => (s.p1Id===p.id||s.p2Id===p.id)&&(cn.targetId===s.id||cn.s1Id===s.id||cn.s2Id===s.id)));
            c.setAttribute("fill", p.fixed ? 'var(--fixed)' : (relC.length >= 2 ? 'var(--defined)' : 'var(--sub)'));
            c.setAttribute("class", `point ${this.selectedIds.has(p.id)?'selected':''} ${this.hoverId===p.id?'hover':''}`);
            canvas.appendChild(c);
        });
        document.getElementById('constraint-list').innerHTML = this.state.constraints.map((c, i) => `
            <div class="constraint-item">
                <span><b>${c.type}</b> ${c.value !== undefined ? ': '+Math.round(c.value) : ''}</span>
                <button class="btn-del-c" onclick="sketcher.deleteConstraint(${i})">&#10006;</button>
            </div>
        `).join('');
    }
}
const sketcher = new CADSketcher();
</script>
</body>
</html>
