<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>RaizCuadra CAD - Pro Sketcher</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.15/paper-full.min.js"></script>
    <style>
        :root {
            --bg: #0d0d0d; --panel: #1a1a1a; --accent: #00ff41; /* Estética RaizCuadra */
            --blue: #3b82f6; --black: #e0e0e0; --red: #ff4d4d;
        }
        body { margin: 0; background: var(--bg); color: white; font-family: 'Courier New', monospace; display: flex; height: 100vh; overflow: hidden; }
        
        /* Sidebar Estética RaizCuadra */
        #sidebar { width: 280px; background: var(--panel); border-right: 1px solid #333; display: flex; flex-direction: column; padding: 15px; }
        .tool-group { margin-bottom: 20px; }
        .tool-group h3 { font-size: 12px; color: var(--accent); text-transform: uppercase; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .btn { width: 100%; background: transparent; border: 1px solid #444; color: #aaa; padding: 8px; margin: 4px 0; cursor: pointer; text-align: left; font-size: 11px; transition: 0.2s; }
        .btn:hover { border-color: var(--accent); color: white; }
        .btn.active { background: #333; border-color: var(--accent); color: var(--accent); }
        
        #viewport { flex-grow: 1; position: relative; cursor: crosshair; }
        canvas { width: 100%; height: 100%; background: radial-gradient(#222 1px, transparent 1px); background-size: 30px 30px; }
        
        /* Editor Flotante */
        #dim-editor { position: absolute; display: none; background: var(--panel); border: 1px solid var(--accent); padding: 5px; box-shadow: 0 0 10px rgba(0,255,65,0.2); }
        #dim-editor input { background: black; border: 1px solid #444; color: var(--accent); width: 60px; text-align: center; outline: none; }
        
        .status-bar { position: absolute; bottom: 0; left: 280px; right: 0; background: rgba(0,0,0,0.8); padding: 5px 15px; font-size: 10px; display: flex; gap: 20px; border-top: 1px solid #333; }
        .status-blue { color: var(--blue); } .status-black { color: var(--accent); } .status-red { color: var(--red); }
    </style>
</head>
<body>

<div id="sidebar">
    <div style="font-size: 18px; font-weight: bold; margin-bottom: 20px; color: var(--accent);">[RAIZ_CUADRA] CAD</div>
    
    <div class="tool-group">
        <h3>Entidades</h3>
        <button class="btn active" id="tool-line" onclick="setMode('LINE')">> LINEA</button>
        <button class="btn" id="tool-circle" onclick="setMode('CIRCLE')">> CIRCULO</button>
        <button class="btn" id="tool-rect" onclick="setMode('RECT')">> RECTANGULO</button>
        <button class="btn" id="tool-arc" onclick="setMode('ARC')">> ARCO</button>
        <button class="btn" id="tool-trim" onclick="setMode('TRIM')">> RECORTAR (TRIM)</button>
    </div>

    <div class="tool-group">
        <h3>Relaciones</h3>
        <button class="btn" onclick="addRelation('HORIZ')">> HORIZONTAL</button>
        <button class="btn" onclick="addRelation('VERT')">> VERTICAL</button>
        <button class="btn" onclick="addRelation('FIX')">> FIJAR (GROUND)</button>
        <button class="btn" onclick="addRelation('COINC')">> COINCIDENTE</button>
        <button class="btn" onclick="addRelation('EQUAL')">> IGUALDAD</button>
    </div>

    <div class="tool-group">
        <h3>Dimensiones</h3>
        <button class="btn" onclick="setMode('DIM')">> COTA INTELIGENTE</button>
    </div>

    <div id="constraint-info" style="font-size: 10px; color: #666; margin-top: auto;">
        DOF: <span id="dof-count">0</span> | ESTADO: <span id="sketch-state">LISTO</span>
    </div>
</div>

<div id="viewport">
    <canvas id="cadCanvas" resize></canvas>
    <div id="dim-editor"><input type="number" id="dim-input"></div>
    <div class="status-bar">
        <span class="status-blue">● SUBDEFINIDO</span>
        <span class="status-black">● TOTALMENTE DEFINIDO</span>
        <span class="status-red">● SOBREDEFINIDO</span>
    </div>
</div>

<script>
// --- CONFIGURACIÓN PAPER.JS ---
paper.setup('cadCanvas');
const { Path, Point, Group, Color, TextItem } = paper;

// --- MOTOR DE RESTRICCIONES (GCS) ---
class ConstraintSolver {
    constructor() {
        this.points = []; // Referencias a objetos Point de Paper.js
        this.constraints = [];
        this.iterations = 100;
        this.epsilon = 0.001;
    }

    solve() {
        for (let i = 0; i < this.iterations; i++) {
            let maxError = 0;
            this.constraints.forEach(c => {
                maxError = Math.max(maxError, this.apply(c));
            });
            if (maxError < this.epsilon) break;
        }
    }

    apply(c) {
        switch(c.type) {
            case 'FIX':
                c.p1.x = c.valX; c.p1.y = c.valY;
                return 0;
            case 'HORIZ':
                let avgY = (c.p1.y + c.p2.y) / 2;
                let errH = Math.abs(c.p1.y - c.p2.y);
                if(!c.p1.fixed) c.p1.y = avgY;
                if(!c.p2.fixed) c.p2.y = avgY;
                return errH;
            case 'VERT':
                let avgX = (c.p1.x + c.p2.x) / 2;
                let errV = Math.abs(c.p1.x - c.p2.x);
                if(!c.p1.fixed) c.p1.x = avgX;
                if(!c.p2.fixed) c.p2.x = avgX;
                return errV;
            case 'DIST':
                let dx = c.p2.x - c.p1.x, dy = c.p2.y - c.p1.y;
                let d = Math.sqrt(dx*dx + dy*dy);
                if (d === 0) return 0;
                let diff = (d - c.value) / d * 0.5;
                if(!c.p1.fixed) { c.p1.x += dx * diff; c.p1.y += dy * diff; }
                if(!c.p2.fixed) { c.p2.x -= dx * diff; c.p2.y -= dy * diff; }
                return Math.abs(d - c.value);
            case 'COINC':
                let mx = (c.p1.x + c.p2.x)/2, my = (c.p1.y + c.p2.y)/2;
                c.p1.x = mx; c.p1.y = my; c.p2.x = mx; c.p2.y = my;
                return 0;
        }
        return 0;
    }
}

const solver = new ConstraintSolver();

// --- ESTADO GLOBAL ---
let mode = 'LINE';
let entities = [];
let selectedEntities = [];
let tempPath = null;
const origin = new Point(window.innerWidth/2 - 140, window.innerHeight/2);

// --- DIBUJO DEL ORIGEN ---
const drawOrigin = () => {
    new Path.Circle({ center: origin, radius: 5, strokeColor: '#00ff41', strokeWidth: 1 });
    new Path.Line(origin.add([-10,0]), origin.add([10,0])).strokeColor = '#444';
    new Path.Line(origin.add([0,-10]), origin.add([0,10])).strokeColor = '#444';
};
drawOrigin();

// --- GESTIÓN DE HERRAMIENTAS ---
function setMode(m) {
    mode = m;
    document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
    document.getElementById('tool-' + m.toLowerCase())?.classList.add('active');
}

const tool = new paper.Tool();

tool.onMouseDown = (event) => {
    const hit = paper.project.hitTest(event.point, { segments: true, stroke: true, tolerance: 10 });
    
    if (mode === 'SELECT' || mode === 'DIM') {
        if (hit) {
            if (mode === 'DIM' && hit.item.data.type === 'segment') {
                createDimension(hit.item);
            } else {
                hit.item.selected = !hit.item.selected;
            }
        }
        return;
    }

    if (mode === 'LINE') {
        tempPath = new Path.Line(event.point, event.point);
        tempPath.strokeColor = '#3b82f6';
        tempPath.strokeWidth = 2;
        tempPath.data.type = 'segment';
    }
    
    if (mode === 'CIRCLE') {
        tempPath = new Path.Circle(event.point, 1);
        tempPath.strokeColor = '#3b82f6';
        tempPath.data.type = 'circle';
    }
};

tool.onMouseDrag = (event) => {
    if (tempPath && mode === 'LINE') {
        tempPath.segments[1].point = event.point;
    }
    if (tempPath && mode === 'CIRCLE') {
        tempPath.scale(event.point.getDistance(tempPath.position) / (tempPath.bounds.width/2));
    }
};

tool.onMouseUp = (event) => {
    if (tempPath) {
        entities.push(tempPath);
        // Al soltar, calculamos grados de libertad y definimos color inicial
        updateSketchState();
        tempPath = null;
    }
};

// --- LÓGICA DE DIMENSIONADO ---
function createDimension(path) {
    const p1 = path.segments[0].point;
    const p2 = path.segments[1].point;
    const dist = p1.getDistance(p2);
    
    const dimVal = prompt("Valor de cota:", dist.toFixed(2));
    if (dimVal) {
        solver.constraints.push({
            type: 'DIST',
            p1: p1,
            p2: p2,
            value: parseFloat(dimVal)
        });
        
        // Agregar referencia visual de cota
        const label = new TextItem({
            point: p1.add(p2).divide(2).add([0, -15]),
            content: dimVal,
            fillColor: '#00ff41',
            fontSize: 12,
            fontFamily: 'Courier New'
        });
        
        solveAndRender();
    }
}

// --- ACTUALIZACIÓN DEL SOLVER Y RENDER ---
function solveAndRender() {
    solver.solve();
    updateSketchState();
    paper.view.draw();
}

function updateSketchState() {
    // Lógica simplificada de definición de colores
    entities.forEach(entity => {
        let isFixed = false;
        // Si el punto está cerca del origen, lo fijamos automáticamente (Coincidente Origen)
        entity.segments?.forEach(seg => {
            if(seg.point.getDistance(origin) < 5) {
                seg.point.x = origin.x; seg.point.y = origin.y;
                seg.point.fixed = true;
                isFixed = true;
            }
        });

        // Contar restricciones asociadas a esta entidad
        const relevantConstraints = solver.constraints.filter(c => 
            (c.p1 && entity.segments.some(s => s.point === c.p1)) || 
            (c.p2 && entity.segments.some(s => s.point === c.p2))
        );

        if (relevantConstraints.length >= 2 || isFixed) {
            entity.strokeColor = '#00ff41'; // Totalmente definido (Negro/Verde RaizCuadra)
        } else {
            entity.strokeColor = '#3b82f6'; // Subdefinido
        }
    });
}

function addRelation(type) {
    const selected = paper.project.selectedItems;
    if (selected.length === 0) return;

    selected.forEach(item => {
        if (type === 'HORIZ' && item.data.type === 'segment') {
            solver.constraints.push({ type: 'HORIZ', p1: item.segments[0].point, p2: item.segments[1].point });
        }
        if (type === 'VERT' && item.data.type === 'segment') {
            solver.constraints.push({ type: 'VERT', p1: item.segments[0].point, p2: item.segments[1].point });
        }
        if (type === 'FIX') {
            item.segments.forEach(s => {
                solver.constraints.push({ type: 'FIX', p1: s.point, valX: s.point.x, valY: s.point.y });
                s.point.fixed = true;
            });
        }
    });
    
    solveAndRender();
}

// --- TOOL: TRIM (RECORTAR) ---
function trimEntity(point) {
    const hit = paper.project.hitTest(point, { stroke: true, tolerance: 5 });
    if (hit && hit.item) {
        hit.item.remove();
        entities = entities.filter(e => e !== hit.item);
        // Limpiar restricciones huérfanas
        solver.constraints = solver.constraints.filter(c => 
            entities.some(e => e.segments.some(s => s.point === c.p1 || s.point === c.p2))
        );
        solveAndRender();
    }
}

// Escuchar teclas para borrar
window.onkeydown = (e) => {
    if (e.key === 'Delete' || e.key === 'Backspace') {
        paper.project.selectedItems.forEach(item => item.remove());
        solveAndRender();
    }
};

</script>
</body>
</html>
