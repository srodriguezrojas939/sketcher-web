<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProCAD Sketcher v3 - Full Parametric</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Open+Sans:wght@400;600&display=swap');
        :root { 
            --bg: #F3F4F6; --panel: #FFFFFF; --black: #111827; 
            --blue: #2563EB; --red: #EF4444; --gray: #9CA3AF; 
            --fixed: #064E3B; --defined: #10B981; --sub: #3B82F6;
            --select: #F59E0B; --hover: #D1D5DB;
        }
        body { margin: 0; font-family: 'Open Sans', sans-serif; background: var(--bg); color: var(--black); display: grid; grid-template-columns: 280px 1fr 280px; grid-template-rows: auto 1fr; height: 100vh; overflow: hidden; }
        header { grid-column: 1 / -1; padding: 10px 25px; background: var(--panel); border-bottom: 1px solid #E5E7EB; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        header h1 { font-family: 'Playfair Display', serif; font-size: 18px; margin: 0; }
        .sidebar, .right-panel { background: var(--panel); padding: 15px; overflow-y: auto; border-color: #E5E7EB; border-style: solid; }
        .sidebar { border-right-width: 1px; display: flex; flex-direction: column; gap: 8px; }
        .right-panel { border-left-width: 1px; }
        .tool-group h3 { font-size: 10px; text-transform: uppercase; color: var(--gray); margin: 0 0 8px 0; letter-spacing: 1px; }
        .btn { width: 100%; padding: 8px 10px; border-radius: 6px; border: 1px solid #F3F4F6; background: white; cursor: pointer; font-weight: 600; text-align: left; display: flex; align-items: center; gap: 10px; font-size: 12px; transition: 0.2s; }
        .btn:hover { background: #F9FAFB; }
        .btn.active { background: var(--black); color: white; }
        .undo-redo-row { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 10px; }
        #viewport { position: relative; background: white; overflow: hidden; cursor: crosshair; }
        svg { width: 100%; height: 100%; touch-action: none; }
        
        /* Estilos Geometr√≠a */
        .sketch-line { stroke: var(--black); stroke-width: 2; fill: none; transition: stroke 0.2s; }
        .sketch-line.selected { stroke: var(--select); stroke-width: 3; }
        .sketch-line.hover { stroke: var(--hover); }
        
        .sketch-circle { stroke: var(--black); stroke-width: 2; fill: rgba(0,0,0,0.02); }
        .sketch-circle.selected { stroke: var(--select); stroke-width: 3; }
        
        .point { stroke-width: 1.5; cursor: move; transition: r 0.2s; }
        .point.hover { r: 6; }
        .point.selected { stroke: var(--select); stroke-width: 3; }

        .dim-text { fill: var(--blue); font-weight: 700; font-size: 11px; cursor: pointer; user-select: none; }
        .angle-text { fill: var(--red); font-weight: 700; font-size: 11px; cursor: pointer; }
        
        .constraint-item { font-size: 11px; padding: 6px; background: #F9FAFB; border: 1px solid #E5E7EB; border-radius: 4px; margin-bottom: 3px; display: flex; justify-content: space-between; align-items: center; }
        .btn-del-c { color: var(--red); border: none; background: none; cursor: pointer; font-weight: bold; font-size: 14px; }
        
        .legend { font-size: 10px; margin-top: 10px; padding: 5px; border-top: 1px solid #EEE; }
        .dot { height: 8px; width: 8px; border-radius: 50%; display: inline-block; margin-right: 5px; }
    </style>
</head>
<body>

<header>
    <h1>ProCAD Sketcher v3</h1>
    <div style="font-family: 'Playfair Display'; font-weight: 700; font-size: 14px;">PARAMETRIC ENGINE</div>
</header>

<div class="sidebar">
    <div class="undo-redo-row">
        <button class="btn" onclick="sketcher.undo()">‚ü≤ Deshacer</button>
        <button class="btn" onclick="sketcher.redo()">‚ü≥ Rehacer</button>
    </div>
    
    <div class="tool-group">
        <h3>Dibujo</h3>
        <button class="btn active" id="btn-LINE" onclick="sketcher.setMode('LINE')">üìè L√≠nea</button>
        <button class="btn" id="btn-CIRCLE" onclick="sketcher.setMode('CIRCLE')">‚≠ï C√≠rculo</button>
        <button class="btn" id="btn-RECT" onclick="sketcher.setMode('RECT')">üü¶ Rect√°ngulo</button>
        <button class="btn" id="btn-SELECT" onclick="sketcher.setMode('SELECT')">üñ±Ô∏è Seleccionar</button>
    </div>

    <div class="tool-group">
        <h3>Restricciones</h3>
        <button class="btn" onclick="sketcher.setMode('DIM')">üè∑Ô∏è Longitud</button>
        <button class="btn" onclick="sketcher.setMode('ANGLE')">üìê √Ångulo</button>
        <button class="btn" onclick="sketcher.addConstraintFromSelection('HORIZ')">‚ñ¨ Horizontal</button>
        <button class="btn" onclick="sketcher.addConstraintFromSelection('VERT')">‚ñÆ Vertical</button>
        <button class="btn" onclick="sketcher.addConstraintFromSelection('COINCIDENT')">üîó Coincidente</button>
        <button class="btn" onclick="sketcher.addConstraintFromSelection('MIDPOINT')">üìç Punto Medio</button>
        <button class="btn" onclick="sketcher.addConstraintFromSelection('EQUAL')">‚öñÔ∏è Igualdad</button>
        <button class="btn" onclick="sketcher.addConstraintFromSelection('PARALLEL')">‚à• Paralelo</button>
        <button class="btn" onclick="sketcher.addConstraintFromSelection('PERPENDICULAR')">‚ä• Perpendicular</button>
        <button class="btn" onclick="sketcher.toggleFixed()">‚öì Fijar (Ground)</button>
    </div>

    <div class="tool-group">
        <h3>Edici√≥n</h3>
        <button class="btn" id="btn-TRIM" onclick="sketcher.setMode('TRIM')">‚úÇÔ∏è Tijeras (Trim)</button>
    </div>

    <div class="legend">
        <div><span class="dot" style="background:var(--fixed)"></span> Fijo (Anclado)</div>
        <div><span class="dot" style="background:var(--defined)"></span> Definido</div>
        <div><span class="dot" style="background:var(--sub)"></span> Sub-definido</div>
    </div>
</div>

<div id="viewport">
    <svg id="canvas"></svg>
</div>

<div class="right-panel">
    <div class="tool-group">
        <h3>Restricciones Activas</h3>
        <div id="constraint-list"></div>
    </div>
</div>

<script>
class SketchState {
    constructor() {
        this.points = [];
        this.segments = [];
        this.circles = [];
        this.constraints = [];
    }
    clone() {
        const newState = new SketchState();
        newState.points = JSON.parse(JSON.stringify(this.points));
        newState.segments = JSON.parse(JSON.stringify(this.segments));
        newState.circles = JSON.parse(JSON.stringify(this.circles));
        newState.constraints = JSON.parse(JSON.stringify(this.constraints));
        return newState;
    }
}

class CADSketcher {
    constructor() {
        this.state = new SketchState();
        this.history = [];
        this.redoStack = [];
        this.mode = 'LINE';
        this.tempIds = [];
        this.dragNode = null;
        this.EPS = 1e-6;
        
        // ADDITION: Selecci√≥n y Hover
        this.selectedIds = new Set();
        this.hoverId = null;

        this.svg = document.getElementById('canvas');
        this.initEvents();
    }

    saveHistory() {
        this.history.push(this.state.clone());
        this.redoStack = [];
        if (this.history.length > 50) this.history.shift();
    }

    undo() {
        if (this.history.length > 0) {
            this.redoStack.push(this.state.clone());
            this.state = this.history.pop();
            this.render();
        }
    }

    redo() {
        if (this.redoStack.length > 0) {
            this.history.push(this.state.clone());
            this.state = this.redoStack.pop();
            this.render();
        }
    }

    // --- SOLVER ---
    solve() {
        const iterations = 50;
        for (let i = 0; i < iterations; i++) {
            let maxErr = 0;
            this.state.constraints.forEach(c => {
                maxErr = Math.max(maxErr, this.applyConstraint(c));
            });
            if (maxErr < this.EPS) break;
        }
    }

    applyConstraint(c) {
        // --- RESTRICCIONES ORIGINALES ---
        if (c.type === 'DIST') {
            const s = this.state.segments.find(seg => seg.id === c.targetId);
            if (!s) return 0;
            const p1 = this.findPoint(s.p1Id), p2 = this.findPoint(s.p2Id);
            const dx = p2.x - p1.x, dy = p2.y - p1.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < this.EPS) return 0;
            const ratio = (dist - c.value) / dist * 0.5;
            this.movePoint(p1, dx * ratio, dy * ratio);
            this.movePoint(p2, -dx * ratio, -dy * ratio);
            return Math.abs(dist - c.value);
        }
        if (c.type === 'HORIZ' || c.type === 'VERT') {
            const s = this.state.segments.find(seg => seg.id === c.targetId);
            if (!s) return 0;
            const p1 = this.findPoint(s.p1Id), p2 = this.findPoint(s.p2Id);
            if (c.type === 'HORIZ') {
                const avgY = (p1.y + p2.y) / 2;
                this.setPointPos(p1, null, avgY); this.setPointPos(p2, null, avgY);
                return Math.abs(p1.y - p2.y);
            } else {
                const avgX = (p1.x + p2.x) / 2;
                this.setPointPos(p1, avgX, null); this.setPointPos(p2, avgX, null);
                return Math.abs(p1.x - p2.x);
            }
        }
        if (c.type === 'ANGLE') {
            const s1 = this.state.segments.find(s => s.id === c.s1Id);
            const s2 = this.state.segments.find(s => s.id === c.s2Id);
            if (!s1 || !s2) return 0;
            const commonId = [s1.p1Id, s1.p2Id].find(id => id === s2.p1Id || id === s2.p2Id);
            if (!commonId) return 0;
            const v = this.findPoint(commonId);
            const other2Id = (s2.p1Id === commonId) ? s2.p2Id : s2.p1Id;
            const other1Id = (s1.p1Id === commonId) ? s1.p2Id : s1.p1Id;
            const p1 = this.findPoint(other1Id), p2 = this.findPoint(other2Id);
            const a1 = Math.atan2(p1.y - v.y, p1.x - v.x);
            const a2 = Math.atan2(p2.y - v.y, p2.x - v.x);
            const diff = (c.value * Math.PI / 180) - (a2 - a1);
            const cos = Math.cos(diff), sin = Math.sin(diff);
            const rx = p2.x - v.x, ry = p2.y - v.y;
            this.setPointPos(p2, v.x + (rx * cos - ry * sin), v.y + (rx * sin + ry * cos));
            return Math.abs(diff);
        }

        // --- ADDITION: NUEVAS RESTRICCIONES ---
        if (c.type === 'COINCIDENT') {
            const pA = this.findPoint(c.p1Id);
            if (c.p2Id) { // Punto a Punto
                const pB = this.findPoint(c.p2Id);
                const mx = (pA.x + pB.x) / 2, my = (pA.y + pB.y) / 2;
                this.setPointPos(pA, mx, my); this.setPointPos(pB, mx, my);
                return Math.hypot(pA.x - pB.x, pA.y - pB.y);
            } else if (c.segId) { // Punto a Segmento
                const s = this.state.segments.find(seg => seg.id === c.segId);
                if (!s) return 0;
                const sp1 = this.findPoint(s.p1Id), sp2 = this.findPoint(s.p2Id);
                const dx = sp2.x - sp1.x, dy = sp2.y - sp1.y;
                const l2 = dx*dx + dy*dy;
                let t = ((pA.x - sp1.x) * dx + (pA.y - sp1.y) * dy) / l2;
                t = Math.max(0, Math.min(1, t));
                const px = sp1.x + t * dx, py = sp1.y + t * dy;
                const err = Math.hypot(pA.x - px, pA.y - py);
                this.setPointPos(pA, px, py);
                return err;
            }
        }

        if (c.type === 'MIDPOINT') {
            const p = this.findPoint(c.pId);
            const s = this.state.segments.find(seg => seg.id === c.segId);
            if (!s) return 0;
            const sp1 = this.findPoint(s.p1Id), sp2 = this.findPoint(s.p2Id);
            const mx = (sp1.x + sp2.x) / 2, my = (sp1.y + sp2.y) / 2;
            const err = Math.hypot(p.x - mx, p.y - my);
            this.setPointPos(p, mx, my);
            return err;
        }

        if (c.type === 'EQUAL') {
            const s1 = this.state.segments.find(s => s.id === c.s1Id);
            const s2 = this.state.segments.find(s => s.id === c.s2Id);
            if (!s1 || !s2) return 0;
            const l1 = Math.hypot(this.findPoint(s1.p1Id).x - this.findPoint(s1.p2Id).x, this.findPoint(s1.p1Id).y - this.findPoint(s1.p2Id).y);
            const l2 = Math.hypot(this.findPoint(s2.p1Id).x - this.findPoint(s2.p2Id).x, this.findPoint(s2.p1Id).y - this.findPoint(s2.p2Id).y);
            const avg = (l1 + l2) / 2;
            this.applyConstraint({type: 'DIST', targetId: s1.id, value: avg});
            this.applyConstraint({type: 'DIST', targetId: s2.id, value: avg});
            return Math.abs(l1 - l2);
        }

        if (c.type === 'PARALLEL' || c.type === 'PERPENDICULAR') {
            const s1 = this.state.segments.find(s => s.id === c.s1Id);
            const s2 = this.state.segments.find(s => s.id === c.s2Id);
            if (!s1 || !s2) return 0;
            const p1a = this.findPoint(s1.p1Id), p1b = this.findPoint(s1.p2Id);
            const p2a = this.findPoint(s2.p1Id), p2b = this.findPoint(s2.p2Id);
            const angle1 = Math.atan2(p1b.y - p1a.y, p1b.x - p1a.x);
            const targetAngle = (c.type === 'PARALLEL') ? angle1 : angle1 + Math.PI/2;
            const len2 = Math.hypot(p2b.x - p2a.x, p2b.y - p2a.y);
            const nx = p2a.x + Math.cos(targetAngle) * len2;
            const ny = p2a.y + Math.sin(targetAngle) * len2;
            const err = Math.hypot(p2b.x - nx, p2b.y - ny);
            this.setPointPos(p2b, nx, ny);
            return err;
        }
        
        return 0;
    }

    movePoint(p, dx, dy) { if (!p.fixed && p !== this.dragNode) { p.x += dx; p.y += dy; } }
    setPointPos(p, x, y) { if (!p.fixed && p !== this.dragNode) { if (x !== null) p.x = x; if (y !== null) p.y = y; } }

    // --- GEOMETR√çA ---
    findPoint(id) { return this.state.points.find(p => p.id === id); }
    getSegmentDist(x, y, seg) {
        const p1 = this.findPoint(seg.p1Id), p2 = this.findPoint(seg.p2Id);
        const l2 = Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2);
        if (l2 === 0) return Math.hypot(x - p1.x, y - p1.y);
        let t = ((x - p1.x) * (p2.x - p1.x) + (y - p1.y) * (p2.y - p1.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        return Math.hypot(x - (p1.x + t * (p2.x - p1.x)), y - (p1.y + t * (p2.y - p1.y)));
    }

    // --- INTERACCI√ìN ---
    initEvents() {
        this.svg.onmousedown = (e) => {
            const { x, y } = this.getCoords(e);
            const snapPoint = this.state.points.find(p => Math.hypot(p.x - x, p.y - y) < 12);
            const snapSeg = this.state.segments.find(s => this.getSegmentDist(x, y, s) < 8);
            
            // ADDITION: Manejo de selecci√≥n con Shift
            if (this.mode === 'SELECT') {
                const target = snapPoint || snapSeg;
                if (target) {
                    if (!e.shiftKey) this.selectedIds.clear();
                    if (this.selectedIds.has(target.id)) this.selectedIds.delete(target.id);
                    else this.selectedIds.add(target.id);
                } else if (!e.shiftKey) {
                    this.selectedIds.clear();
                }
            }

            if (this.mode === 'TRIM') return this.trim(x, y);

            const p = snapPoint || { x, y, id: 'P' + Date.now() + Math.random(), fixed: false };
            if (!snapPoint && this.mode !== 'SELECT') this.state.points.push(p);

            if (this.mode === 'LINE') {
                if (this.tempIds[0]) {
                    this.saveHistory();
                    const seg = { p1Id: this.tempIds[0], p2Id: p.id, id: 'S' + Date.now() };
                    this.state.segments.push(seg);
                    this.state.constraints.push({ type: 'DIST', targetId: seg.id, value: Math.hypot(this.findPoint(seg.p1Id).x - p.x, this.findPoint(seg.p1Id).y - p.y) });
                    this.tempIds = [];
                } else { this.tempIds = [p.id]; }
            } else if (this.mode === 'CIRCLE') {
                if (this.tempIds[0]) {
                    this.saveHistory();
                    this.state.circles.push({ centerId: this.tempIds[0], radiusPointId: p.id, id: 'C' + Date.now() });
                    this.tempIds = [];
                } else { this.tempIds = [p.id]; }
            } else if (this.mode === 'RECT') {
                this.saveHistory();
                const p1 = p; p1.fixed = true;
                const p2 = {x: p.x+80, y:p.y, id:'P'+Date.now()+'_2'}, p3 = {x:p.x+80, y:p.y+50, id:'P'+Date.now()+'_3'}, p4 = {x:p.x, y:p.y+50, id:'P'+Date.now()+'_4'};
                this.state.points.push(p2,p3,p4);
                const s1={p1Id:p1.id,p2Id:p2.id,id:'SR1'}, s2={p1Id:p2.id,p2Id:p3.id,id:'SR2'}, s3={p1Id:p3.id,p2Id:p4.id,id:'SR3'}, s4={p1Id:p4.id,p2Id:p1.id,id:'SR4'};
                this.state.segments.push(s1,s2,s3,s4);
                this.state.constraints.push({type:'HORIZ', targetId:s1.id},{type:'VERT', targetId:s2.id},{type:'DIST', targetId:s1.id, value:80},{type:'DIST', targetId:s2.id, value:50});
            } else if (this.mode === 'DIM') {
                if (snapSeg) this.editDimension(snapSeg.id, 'DIST');
            } else if (this.mode === 'ANGLE') {
                if (snapSeg) {
                    if (this.tempIds[0] && this.tempIds[0] !== snapSeg.id) {
                        this.saveHistory();
                        this.state.constraints.push({ type: 'ANGLE', s1Id: this.tempIds[0], s2Id: snapSeg.id, value: 90 });
                        this.tempIds = [];
                    } else { this.tempIds = [snapSeg.id]; }
                }
            } else {
                if (snapPoint) this.dragNode = snapPoint;
            }
            this.solve(); this.render();
        };

        window.onmousemove = (e) => {
            const { x, y } = this.getCoords(e);
            
            // ADDITION: Hover
            const hP = this.state.points.find(p => Math.hypot(p.x - x, p.y - y) < 12);
            const hS = this.state.segments.find(s => this.getSegmentDist(x, y, s) < 8);
            this.hoverId = hP ? hP.id : (hS ? hS.id : null);

            if (this.dragNode) {
                this.dragNode.x = x; this.dragNode.y = y;
                this.solve();
            }
            this.render();
        };
        window.onmouseup = () => this.dragNode = null;
    }

    getCoords(e) { const r = this.svg.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; }
    setMode(m) { this.mode = m; this.tempIds = []; document.querySelectorAll('.btn').forEach(b => b.classList.toggle('active', b.id === 'btn-'+m)); }

    // --- ADDITION: MANEJO DE SELECCI√ìN PARA RESTRICCIONES ---
    addConstraintFromSelection(type) {
        const sel = Array.from(this.selectedIds);
        this.saveHistory();
        
        if (type === 'HORIZ' || type === 'VERT') {
            sel.forEach(id => { if (id.startsWith('S')) this.state.constraints.push({type, targetId: id}); });
        } else if (type === 'COINCIDENT') {
            const pIds = sel.filter(id => id.startsWith('P'));
            const sIds = sel.filter(id => id.startsWith('S'));
            if (pIds.length === 2) this.state.constraints.push({type, p1Id: pIds[0], p2Id: pIds[1]});
            else if (pIds.length === 1 && sIds.length === 1) this.state.constraints.push({type, p1Id: pIds[0], segId: sIds[0]});
        } else if (type === 'MIDPOINT') {
            const pId = sel.find(id => id.startsWith('P')), sId = sel.find(id => id.startsWith('S'));
            if (pId && sId) this.state.constraints.push({type, pId, segId: sId});
        } else if (type === 'EQUAL' || type === 'PARALLEL' || type === 'PERPENDICULAR') {
            const sIds = sel.filter(id => id.startsWith('S'));
            if (sIds.length === 2) this.state.constraints.push({type, s1Id: sIds[0], s2Id: sIds[1]});
        }
        
        this.selectedIds.clear();
        this.solve(); this.render();
    }

    toggleFixed() {
        this.selectedIds.forEach(id => {
            const p = this.findPoint(id);
            if (p) { this.saveHistory(); p.fixed = !p.fixed; }
        });
        this.render();
    }

    deleteConstraint(index) {
        this.saveHistory();
        this.state.constraints.splice(index, 1);
        this.solve(); this.render();
    }

    editDimension(id, type) {
        const c = this.state.constraints.find(c => (c.targetId === id || c.s2Id === id) && c.type === type);
        if (!c) return;
        const val = prompt(`Valor para ${type}:`, Math.round(c.value));
        if (val !== null && !isNaN(val)) { this.saveHistory(); c.value = parseFloat(val); this.solve(); this.render(); }
    }

    trim(x, y) {
        this.saveHistory();
        const seg = this.state.segments.find(s => this.getSegmentDist(x, y, s) < 10);
        if (seg) {
            this.state.constraints = this.state.constraints.filter(c => c.targetId !== seg.id && c.s1Id !== seg.id && c.s2Id !== seg.id && c.segId !== seg.id);
            this.state.segments = this.state.segments.filter(s => s.id !== seg.id);
        }
        // Cleanup hu√©rfanos
        this.state.points = this.state.points.filter(p => 
            this.state.segments.some(s => s.p1Id === p.id || s.p2Id === p.id) ||
            this.state.circles.some(c => c.centerId === p.id || c.radiusPointId === p.id)
        );
        this.render();
    }

    // --- RENDER ---
    render() {
        const canvas = this.svg; canvas.innerHTML = '';
        
        this.state.segments.forEach(s => {
            const p1 = this.findPoint(s.p1Id), p2 = this.findPoint(s.p2Id);
            const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
            l.setAttribute("x1", p1.x); l.setAttribute("y1", p1.y);
            l.setAttribute("x2", p2.x); l.setAttribute("y2", p2.y);
            let cls = "sketch-line";
            if (this.selectedIds.has(s.id)) cls += " selected";
            if (this.hoverId === s.id) cls += " hover";
            l.setAttribute("class", cls);
            canvas.appendChild(l);
            
            const distC = this.state.constraints.find(c => c.targetId === s.id && c.type === 'DIST');
            if (distC) {
                const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
                t.setAttribute("x", (p1.x + p2.x)/2); t.setAttribute("y", (p1.y + p2.y)/2 - 10);
                t.setAttribute("class", "dim-text"); t.setAttribute("text-anchor", "middle");
                t.textContent = Math.round(distC.value);
                t.onclick = (e) => { e.stopPropagation(); this.editDimension(s.id, 'DIST'); };
                canvas.appendChild(t);
            }
        });

        this.state.constraints.filter(c => c.type === 'ANGLE').forEach(c => {
            const s1 = this.state.segments.find(s => s.id === c.s1Id);
            const s2 = this.state.segments.find(s => s.id === c.s2Id);
            if (!s1 || !s2) return;
            const commonId = [s1.p1Id, s1.p2Id].find(id => id === s2.p1Id || id === s2.p2Id);
            const v = this.findPoint(commonId);
            if (!v) return;
            const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
            t.setAttribute("x", v.x + 20); t.setAttribute("y", v.y - 20);
            t.setAttribute("class", "angle-text");
            t.textContent = Math.round(c.value) + "¬∞";
            t.onclick = () => this.editDimension(c.s2Id, 'ANGLE');
            canvas.appendChild(t);
        });

        this.state.points.forEach(p => {
            const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            c.setAttribute("cx", p.x); c.setAttribute("cy", p.y);
            c.setAttribute("r", 4);
            
            // ADDITION: An√°lisis b√°sico de movilidad para color
            const cCount = this.state.constraints.filter(c => 
                c.targetId === p.id || c.p1Id === p.id || c.p2Id === p.id || c.pId === p.id ||
                this.state.segments.some(s => (s.p1Id === p.id || s.p2Id === p.id) && (c.targetId === s.id || c.s1Id === s.id || c.s2Id === s.id))
            ).length;

            let fill = p.fixed ? 'var(--fixed)' : (cCount >= 2 ? 'var(--defined)' : 'var(--sub)');
            c.setAttribute("fill", fill);
            
            let cls = "point";
            if (this.selectedIds.has(p.id)) cls += " selected";
            if (this.hoverId === p.id) cls += " hover";
            c.setAttribute("class", cls);
            canvas.appendChild(c);
        });

        document.getElementById('constraint-list').innerHTML = this.state.constraints.map((c, i) => `
            <div class="constraint-item">
                <span><b>${c.type}</b> ${c.value ? ': '+Math.round(c.value) : ''}</span>
                <button class="btn-del-c" onclick="sketcher.deleteConstraint(${i})">√ó</button>
            </div>
        `).join('');
    }
}

const sketcher = new CADSketcher();
</script>
</body>
</html>
