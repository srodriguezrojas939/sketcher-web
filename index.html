<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>RaizCuadra CAD - Pure Vanilla</title>
    <style>
        :root {
            --bg: #0a0a0a; --panel: #141414; --accent: #00ff41; 
            --blue: #3b82f6; --dim: #fbbf24; --red: #ff4d4d;
        }
        body { margin: 0; background: var(--bg); color: white; font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; overflow: hidden; }
        
        #sidebar { width: 220px; background: var(--panel); border-right: 1px solid #333; padding: 15px; z-index: 10; display: flex; flex-direction: column; }
        .tool-group h3 { font-size: 10px; color: var(--accent); text-transform: uppercase; border-bottom: 1px solid #333; padding-bottom: 5px; margin: 15px 0 10px; }
        
        .btn { 
            width: 100%; background: #1a1a1a; border: 1px solid #333; color: #888; 
            padding: 10px; margin: 3px 0; cursor: pointer; text-align: left; 
            font-size: 11px; transition: 0.2s; border-radius: 4px;
        }
        .btn:hover, .btn.active { border-color: var(--accent); color: white; background: #222; }

        #viewport { flex-grow: 1; position: relative; overflow: hidden; background: #000; }
        canvas { display: block; }

        /* Input Flotante para Cotas */
        #dim-editor {
            position: absolute; display: none; background: #222; border: 1px solid var(--accent);
            padding: 5px; border-radius: 4px; z-index: 100;
        }
        #dim-editor input { background: #000; border: none; color: var(--accent); width: 60px; text-align: center; outline: none; font-weight: bold; }

        .status { position: absolute; bottom: 10px; left: 230px; font-size: 10px; color: #555; display: flex; gap: 15px; }
    </style>
</head>
<body>

<div id="sidebar">
    <div style="font-size: 16px; font-weight: bold; color: var(--accent); margin-bottom: 20px;">RAIZ_CUADRA CAD</div>
    
    <div class="tool-group">
        <h3>Dibujo</h3>
        <button class="btn active" onclick="setMode('LINE')">LÍNEA</button>
        <button class="btn" onclick="setMode('RECT')">RECTÁNGULO</button>
    </div>

    <div class="tool-group">
        <h3>Acotación</h3>
        <button class="btn" onclick="setMode('DIM')">COTA INTELIGENTE</button>
        <button class="btn" onclick="setMode('ANGLE')">COTA ANGULAR</button>
    </div>

    <div style="margin-top: auto; font-size: 9px; color: #444;">VANILLA JS ENGINE // NO LIBS</div>
</div>

<div id="viewport">
    <canvas id="cadCanvas"></canvas>
    
    <div id="dim-editor">
        <input type="number" id="dim-val">
    </div>

    <div class="status">
        <span>● ORIGEN (0,0)</span>
        <span>● SNAP ACTIVO</span>
        <span id="coord-display">X: 0 Y: 0</span>
    </div>
</div>

<script>
const canvas = document.getElementById('cadCanvas');
const ctx = canvas.getContext('2d');
const dimEditor = document.getElementById('dim-editor');
const dimInput = document.getElementById('dim-val');

let width, height, centerX, centerY;
let mode = 'LINE';
let entities = [];
let points = [];
let dimensions = [];
let isDragging = false;
let startPoint = null;
let currentMouse = { x: 0, y: 0 };
let selectedEntity = null;

// --- INICIALIZACIÓN ---
function resize() {
    width = canvas.width = window.innerWidth - 220;
    height = canvas.height = window.innerHeight;
    centerX = width / 2;
    centerY = height / 2;
    draw();
}
window.addEventListener('resize', resize);
resize();

// --- LÓGICA DE DIBUJO ---
function draw() {
    ctx.clearRect(0, 0, width, height);
    
    // 1. Dibujar Rejilla y Ejes
    drawGrid();
    
    // 2. Dibujar Entidades
    entities.forEach(ent => drawEntity(ent));
    
    // 3. Dibujar Cotas
    dimensions.forEach(dim => drawDimension(dim));

    // 4. Dibujar Línea temporal mientras arrastras
    if (isDragging && startPoint) {
        ctx.beginPath();
        ctx.setLineDash([5, 5]);
        ctx.moveTo(startPoint.x + centerX, startPoint.y + centerY);
        ctx.lineTo(currentMouse.x + centerX, currentMouse.y + centerY);
        ctx.strokeStyle = '#3b82f6';
        ctx.stroke();
        ctx.setLineDash([]);
    }

    requestAnimationFrame(draw);
}

function drawGrid() {
    // Ejes Principales
    ctx.beginPath();
    ctx.strokeStyle = '#1a1a1a';
    ctx.moveTo(centerX, 0); ctx.lineTo(centerX, height);
    ctx.moveTo(0, centerY); ctx.lineTo(width, centerY);
    ctx.stroke();

    // Origen
    ctx.beginPath();
    ctx.arc(centerX, centerY, 4, 0, Math.PI * 2);
    ctx.strokeStyle = '#00ff41';
    ctx.stroke();
}

function drawEntity(ent) {
    ctx.beginPath();
    ctx.lineWidth = 2;
    ctx.strokeStyle = ent.selected ? '#fbbf24' : '#3b82f6';

    if (ent.type === 'LINE') {
        ctx.moveTo(ent.p1.x + centerX, ent.p1.y + centerY);
        ctx.lineTo(ent.p2.x + centerX, ent.p2.y + centerY);
    }
    ctx.stroke();
}

function drawDimension(dim) {
    ctx.font = '10px monospace';
    ctx.fillStyle = '#00ff41';
    
    if (dim.type === 'LINEAR') {
        const mx = (dim.p1.x + dim.p2.x) / 2 + centerX;
        const my = (dim.p1.y + dim.p2.y) / 2 + centerY;
        ctx.fillText(dim.value.toFixed(1), mx + dim.offX, my + dim.offY);
        // Línea de referencia
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(0,255,65,0.3)';
        ctx.moveTo(dim.p1.x + centerX, dim.p1.y + centerY);
        ctx.lineTo(mx + dim.offX, my + dim.offY);
        ctx.stroke();
    }
}

// --- SNAPPING Y MOUSE ---
function getSnap(x, y) {
    let worldX = x - centerX;
    let worldY = y - centerY;
    const threshold = 15;

    // Snap al Origen
    if (Math.abs(worldX) < threshold && Math.abs(worldY) < threshold) return { x: 0, y: 0 };
    // Snap a Ejes
    if (Math.abs(worldX) < threshold) worldX = 0;
    if (Math.abs(worldY) < threshold) worldY = 0;
    // Snap a puntos existentes
    for (let p of points) {
        let d = Math.hypot(worldX - p.x, worldY - p.y);
        if (d < threshold) return { x: p.x, y: p.y };
    }
    return { x: worldX, y: worldY };
}

canvas.addEventListener('mousedown', e => {
    const snap = getSnap(e.clientX - 220, e.clientY);
    
    if (mode === 'DIM') {
        // Detectar si tocamos una entidad para acotar
        entities.forEach(ent => {
            if (distToSegment(snap, ent.p1, ent.p2) < 10) {
                showEditor(ent, e.clientX, e.clientY);
            }
        });
        return;
    }

    isDragging = true;
    startPoint = snap;
});

canvas.addEventListener('mousemove', e => {
    const rawX = e.clientX - 220;
    const rawY = e.clientY;
    currentMouse = getSnap(rawX, rawY);
    document.getElementById('coord-display').innerText = `X: ${Math.round(currentMouse.x)} Y: ${Math.round(currentMouse.y)}`;
});

window.addEventListener('mouseup', e => {
    if (isDragging && startPoint) {
        if (mode === 'LINE') {
            const endPoint = currentMouse;
            if (Math.hypot(endPoint.x - startPoint.x, endPoint.y - startPoint.y) > 5) {
                const newPoint1 = addPoint(startPoint.x, startPoint.y);
                const newPoint2 = addPoint(endPoint.x, endPoint.y);
                entities.push({ type: 'LINE', p1: newPoint1, p2: newPoint2, selected: false });
            }
        }
    }
    isDragging = false;
    startPoint = null;
});

// --- FUNCIONES DE AYUDA ---
function addPoint(x, y) {
    let existing = points.find(p => p.x === x && p.y === y);
    if (existing) return existing;
    let newP = { x, y };
    points.push(newP);
    return newP;
}

function distToSegment(p, v, w) {
    const l2 = Math.hypot(v.x - w.x, v.y - w.y) ** 2;
    if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
    let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    t = Math.max(0, Math.min(1, t));
    return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
}

function setMode(m) {
    mode = m;
    document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
    event.target.classList.add('active');
    dimEditor.style.display = 'none';
}

function showEditor(ent, x, y) {
    selectedEntity = ent;
    dimEditor.style.display = 'block';
    dimEditor.style.left = x + 'px';
    dimEditor.style.top = y + 'px';
    
    const currentLen = Math.hypot(ent.p1.x - ent.p2.x, ent.p1.y - ent.p2.y);
    dimInput.value = Math.round(currentLen);
    dimInput.focus();
    dimInput.select();
}

dimInput.onchange = () => {
    if (!selectedEntity) return;
    const newLen = parseFloat(dimInput.value);
    const oldLen = Math.hypot(selectedEntity.p1.x - selectedEntity.p2.x, selectedEntity.p1.y - selectedEntity.p2.y);
    const ratio = newLen / oldLen;
    
    // Ajustar punto 2 manteniendo ángulo
    selectedEntity.p2.x = selectedEntity.p1.x + (selectedEntity.p2.x - selectedEntity.p1.x) * ratio;
    selectedEntity.p2.y = selectedEntity.p1.y + (selectedEntity.p2.y - selectedEntity.p1.y) * ratio;
    
    // Crear la cota visual
    dimensions = dimensions.filter(d => d.parent !== selectedEntity);
    dimensions.push({
        type: 'LINEAR',
        p1: selectedEntity.p1,
        p2: selectedEntity.p2,
        value: newLen,
        offX: 20, offY: -20,
        parent: selectedEntity
    });
    
    dimEditor.style.display = 'none';
};

// --- COTAS ANGULARES (LOGICA BASICA) ---
// Para implementar el arco angular, se requiere detectar dos líneas.
// Aquí se deja la estructura para que al estar en modo ANGLE y seleccionar dos líneas,
// se calcule el Math.atan2 entre sus vectores.

</script>
</body>
</html>
